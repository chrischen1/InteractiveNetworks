#
# This is the server logic of a Shiny web application. You can run the 
# application by clicking 'Run App' above.
#
# Find out more about building applications with Shiny here:
# 
#    http://shiny.rstudio.com/
#
library(rgl)
library(shiny)
library(data.table)
library(igraph)
library(networkD3)

# network_method = 'aracne' # aracne,clr,minet,mrnet,mrnetb
# network_cutoff = 0.0004
# passcode = 'test'
# distance_limit = 1
# target_gene = 'Zm00004b002117'

data_dict <- list(
  'test' = 'networks_test/',
  'davidlab' = 'networks_david/',
  'birchlerlab' = '/mnt/data/chen/networks_birchler/',
  'networks_xiaowen' = '/mnt/data/chen/networks_xiaowen/'
)
total_edge_limit = 10^6
plot_node_limit = 150
min_cutoff_allowed = 1e-10

# Define server logic required to draw a histogram
shinyServer(function(input, output){
  
  load_id_mapping <- reactive({
    input$goButton
    passcode <- isolate(input$password)
    
    out_dir <- data_dict[['test']]
    if(passcode %in% names(data_dict)){
      out_dir <- data_dict[[passcode]]
    }
    id_file_name <- paste0(out_dir,'id_mapping.csv')
    if(file.exists(id_file_name)){
      d <- read.csv(id_file_name,row.names = 1,as.is = T)
      sbl <- d[,1]
      names(sbl) <- rownames(d)
    }else{
      sbl <- NULL
    }
    return(sbl)
  })
  
  load_network <- reactive({
    input$goButton
    passcode <- isolate(input$password)
    network_method <- isolate(input$network_method)
    
    out_dir <- data_dict[['test']]
    if(passcode %in% names(data_dict)){
      out_dir <- data_dict[[passcode]]
    }
    file_name <- paste0(out_dir,network_method,'_network.csv')
    if(file.exists(file_name)){
      n <- fread(file_name,data.table = F,sep = ',',header = T)
    }else{
      return(NULL)
    }
    rownames(n) <- n$V1
    n <- n[,-1]
    return(n)
  })
  
  output$msg <- renderText({
    input$goButton
    withProgress(message = 'Loading data...', value = 0.2,{
      passcode = isolate(input$password)
      network_cutoff <- as.numeric(isolate(input$network_cutoff))
      target_gene <- isolate(input$target_gene)
      network_method <- isolate(input$network_method)
      distance_limit <- as.numeric(isolate(input$distance_limit))
      n <- load_network()
      if(is.null(n)){
        return('No network generated by selected algorithm.')
      }else if(!target_gene %in% rownames(n)){
        return('Target gene name is not found in selected network.')
      }
      adj_n <- abs(n)>=max(quantile(unlist(n,use.names = F),1-network_cutoff),1e-10)
      if(sum(adj_n)>total_edge_limit){
        return('Too many nodes in the network, try with more strict cutoff and/or smaller distance.')
      }
      
      g <- graph_from_adjacency_matrix(adj_n,mode='undirected')
      d1 <- distances(g,target_gene,weights = NA)
      
      v_slt <- colnames(d1)[d1 <= distance_limit]
      v_keep <- which(rownames(n) %in% v_slt)
      
      g1 <- induced_subgraph(g, v_keep)
      if(length(V(g1)) > plot_node_limit ){
        return('Too many nodes in the network, try with more strict cutoff and/or smaller distance.')
      }else if(length(V(g1)) == 1 ){
        return('No nodes other than the source present in the network, try with larger cutoff and/or distance.')
      }else if(! passcode %in% names(data_dict)){
        return('No valid data access code provided, using test data.')
      }else{
        ''
      }
    })
  })
  get_sub_network_genes <- reactive({
    input$goButton
    network_cutoff <- as.numeric(isolate(input$network_cutoff))
    target_gene <- isolate(input$target_gene)
    network_method <- isolate(input$network_method)
    distance_limit <- as.numeric(isolate(input$distance_limit))
    passcode <- isolate(input$password)
    
    out_dir <- data_dict[['test']]
    if(passcode %in% names(data_dict)){
      out_dir <- data_dict[[passcode]]
    }
    tf_list <- read.delim(paste0(out_dir,'tf_list.txt'),as.is = T,header = F)$V1
    n <- load_network()
    sbl <- load_id_mapping()
    
    if(is.null(n)){
      return(NULL)
    }else if(!target_gene %in% rownames(n)){
      return(NULL)
    }
    adj_n <- abs(n)>=max(quantile(unlist(n,use.names = F),1-network_cutoff),min_cutoff_allowed)
    adj_n[!rownames(adj_n) %in%tf_list,] <- 0
    
    if(sum(adj_n)>total_edge_limit){
      return(NULL)
    }
    g <- graph_from_adjacency_matrix(adj_n,mode='undirected',diag = F)
    d1 <- distances(g,target_gene,weights = NA)
    v_slt <- colnames(d1)[d1 <= distance_limit]
    v_keep <- which(rownames(n) %in% v_slt)
    g1 <- induced_subgraph(g, v_keep)
    if(length(V(g1)) > plot_node_limit ){
      return(NULL)
    }
    sbl_names <- names(V(g1))
    dir.create(paste0(out_dir,'/tmp_freq/'),showWarnings = F)
    write.csv(sbl_names,paste0(out_dir,'/tmp_freq/',network_method,'_genes.csv'))
    return(sbl_names)
    
  })
  
  get_sub_network_tf <- reactive({
    input$goButton
    network_cutoff <- as.numeric(isolate(input$network_cutoff))
    target_gene <- isolate(input$target_gene)
    network_method <- isolate(input$network_method)
    distance_limit <- as.numeric(isolate(input$distance_limit))
    passcode <- isolate(input$password)
    
    out_dir <- data_dict[['test']]
    if(passcode %in% names(data_dict)){
      out_dir <- data_dict[[passcode]]
    }
    n <- load_network()
    sbl <- load_id_mapping()
    
    if(is.null(n)){
      return(NULL)
    }else if(!target_gene %in% rownames(n)){
      return(NULL)
    }
    adj_n <- abs(n)>=max(quantile(unlist(n,use.names = F),1-network_cutoff),min_cutoff_allowed)
    
    tf_list <- read.delim(paste0(out_dir,'tf_list.txt'),as.is = T,header = F)$V1
    adj_n[!rownames(adj_n) %in% tf_list,] <- 0
    adj_n[,!colnames(adj_n) %in% tf_list] <- 0
    
    if(sum(adj_n)>total_edge_limit){
      return(NULL)
    }
    g <- graph_from_adjacency_matrix(adj_n,mode='undirected',diag = F)
    d1 <- distances(g,target_gene,weights = NA)
    v_slt <- colnames(d1)[d1 <= distance_limit]
    v_keep <- which(rownames(n) %in% v_slt)
    g1 <- induced_subgraph(g, v_keep)
    if(length(V(g1)) > plot_node_limit ){
      return(NULL)
    }
    sbl_names <- names(V(g1))
    sbl_names2 <- which(sbl_names %in% names(sbl))
    sbl_names[sbl_names2] <- sbl[sbl_names[sbl_names2]]
    
    node_colors <- rep('black',length(V(g1)))
    node_colors [names(V(g1))%in%tf_list] <- 'blue'
    node_colors [names(V(g1))==target_gene] <- 'red'
    
    g2 <- set.vertex.attribute(g1, "name", value=sbl_names)
    g2 <- set.vertex.attribute(g2, "shape", value='none')
    g2 <- set.vertex.attribute(g2, "label.color", value=node_colors)
    
    if(length(E(g2))>0 ){
      edge_weights <- c()
      for(i in 1:length(E(g1))){
        e_i <- E(g1)[i]
        u_v <- unlist(strsplit(as_ids(e_i),split = '|',fixed = T))
        edge_weights <- c(edge_weights,(n[u_v[1],u_v[2]]+n[u_v[2],u_v[1]])/2)
      }
      if(var(edge_weights)>0){
        edge_weights1 <- as.numeric(scale(edge_weights))
        edge_weights1 <- 0.5*(edge_weights1 - min(edge_weights1))+0.5*max(edge_weights1)
      }else{
        edge_weights1 <- rep(1,length(edge_weights))
      }
      E(g2)$width <- edge_weights1
      return(g2)
    }else{
      return(NULL)
    }
    
  })
  
  get_sub_network <- reactive({
    input$goButton
    network_cutoff <- as.numeric(isolate(input$network_cutoff))
    target_gene <- isolate(input$target_gene)
    network_method <- isolate(input$network_method)
    distance_limit <- as.numeric(isolate(input$distance_limit))
    passcode <- isolate(input$password)
    
    out_dir <- data_dict[['test']]
    if(passcode %in% names(data_dict)){
      out_dir <- data_dict[[passcode]]
    }
    n <- load_network()
    sbl <- load_id_mapping()
    
    if(is.null(n)){
      return(NULL)
    }else if(!target_gene %in% rownames(n)){
      return(NULL)
    }
    adj_n <- abs(n)>=max(quantile(unlist(n,use.names = F),1-network_cutoff),min_cutoff_allowed)
    
    tf_list <- read.delim(paste0(out_dir,'tf_list.txt'),as.is = T,header = F)$V1
    adj_n[!rownames(adj_n) %in%tf_list,] <- 0
    
    if(sum(adj_n)>total_edge_limit){
      return(NULL)
    }
    g <- graph_from_adjacency_matrix(adj_n,mode='undirected',diag = F)
    d1 <- distances(g,target_gene,weights = NA)
    v_slt <- colnames(d1)[d1 <= distance_limit]
    v_keep <- which(rownames(n) %in% v_slt)
    g1 <- induced_subgraph(g, v_keep)
    if(length(V(g1)) > plot_node_limit ){
      return(NULL)
    }
    sbl_names <- names(V(g1))
    sbl_names2 <- which(sbl_names %in% names(sbl))
    sbl_names[sbl_names2] <- sbl[sbl_names[sbl_names2]]
    
    node_colors <- rep('black',length(V(g1)))
    node_colors [names(V(g1))%in%tf_list] <- 'blue'
    node_colors [names(V(g1))==target_gene] <- 'red'
    
    g2 <- set.vertex.attribute(g1, "name", value=sbl_names)
    g2 <- set.vertex.attribute(g2, "shape", value='none')
    g2 <- set.vertex.attribute(g2, "label.color", value=node_colors)
    
    if(length(E(g2))>0 ){
      edge_weights <- c()
      for(i in 1:length(E(g1))){
        e_i <- E(g1)[i]
        u_v <- unlist(strsplit(as_ids(e_i),split = '|',fixed = T))
        edge_weights <- c(edge_weights,(n[u_v[1],u_v[2]]+n[u_v[2],u_v[1]])/2)
      }
      if(var(edge_weights)>0){
        edge_weights1 <- as.numeric(scale(edge_weights))
        edge_weights1 <- 0.5*(edge_weights1 - min(edge_weights1))+0.5*max(edge_weights1)
      }else{
        edge_weights1 <- rep(1,length(edge_weights))
      }
      E(g2)$width <- edge_weights1
      return(g2)
    }else{
      return(NULL)
    }
    
  })

  get_sub_network_full <- reactive({
    input$goButton
    network_cutoff <- as.numeric(isolate(input$network_cutoff))
    target_gene <- isolate(input$target_gene)
    network_method <- isolate(input$network_method)
    distance_limit <- as.numeric(isolate(input$distance_limit))
    passcode <- isolate(input$password)
    
    out_dir <- data_dict[['test']]
    if(passcode %in% names(data_dict)){
      out_dir <- data_dict[[passcode]]
    }
    n <- load_network()
    sbl <- load_id_mapping()
    tf_list <- read.delim(paste0(out_dir,'tf_list.txt'),as.is = T,header = F)$V1
    if(is.null(n)){
      return(NULL)
    }else if(!target_gene %in% rownames(n)){
      return(NULL)
    }
    adj_n <- abs(n)>=max(quantile(unlist(n,use.names = F),1-network_cutoff),min_cutoff_allowed)
    if(sum(adj_n)>total_edge_limit){
      return(NULL)
    }
    g <- graph_from_adjacency_matrix(adj_n,mode='undirected',diag = F)
    d1 <- distances(g,target_gene,weights = NA)
    v_slt <- colnames(d1)[d1 <= distance_limit]
    v_keep <- which(rownames(n) %in% v_slt)
    g1 <- induced_subgraph(g, v_keep)
    if(length(V(g1)) > plot_node_limit ){
      return(NULL)
    }
    sbl_names <- names(V(g1))
    sbl_names2 <- which(sbl_names %in% names(sbl))
    sbl_names[sbl_names2] <- sbl[sbl_names[sbl_names2]]
    
    node_colors <- rep('black',length(V(g1)))
    node_colors [names(V(g1))%in%tf_list] <- 'blue'
    node_colors [names(V(g1))==target_gene] <- 'red'
    
    g2 <- set.vertex.attribute(g1, "name", value=sbl_names)
    g2 <- set.vertex.attribute(g2, "shape", value='none')
    g2 <- set.vertex.attribute(g2, "label.color", value=node_colors)
    
    if(length(E(g2))>0 ){
      edge_weights <- c()
      for(i in 1:length(E(g1))){
        e_i <- E(g1)[i]
        u_v <- unlist(strsplit(as_ids(e_i),split = '|',fixed = T))
        edge_weights <- c(edge_weights,(n[u_v[1],u_v[2]]+n[u_v[2],u_v[1]])/2)
      }
      if(var(edge_weights)>0){
        edge_weights1 <- as.numeric(scale(edge_weights))
        edge_weights1 <- 0.5*(edge_weights1 - min(edge_weights1))+0.5*max(edge_weights1)
      }else{
        edge_weights1 <- rep(1,length(edge_weights))
      }
      E(g2)$width <- edge_weights1
      return(g2)
    }else{
      return(NULL)
    }
    
  })
  
  output$plot_2d_tf <- renderForceNetwork({
    input$goButton
    withProgress(message = 'Generating 2D plot...', value = 0.5,{
      g2 <- get_sub_network_tf()
      if(!is.null(g2)){
        g2_d3 <- igraph_to_networkD3(g2, group = V(g2)$label.color)
        g2_d3$nodes$Nodesize = 0
        ColourScale <- 'd3.scaleOrdinal().domain(["red", "black","blue"]).range(["#FF0000", "#000000","#0249fc"]);'
        forceNetwork(Links = g2_d3$links, Nodes = g2_d3$nodes, 
                     Source = 'source', Target = 'target', Value = 'value',fontSize=9,colourScale = JS(ColourScale),
                     NodeID = 'name', Group = 'group',opacityNoHover = 1,opacity = 1,zoom = T)
      }else{
        plot(1,1,type='n',xaxt='n',yaxt='n',xlab = '',ylab = '',bty="n")
      }
    })
  })
  
  output$plot_2d <- renderForceNetwork({
    input$goButton
    withProgress(message = 'Generating 2D plot...', value = 0.5,{
      g2 <- get_sub_network()
      if(!is.null(g2)){
        g2_d3 <- igraph_to_networkD3(g2, group = V(g2)$label.color)
        g2_d3$nodes$Nodesize = 0
        ColourScale <- 'd3.scaleOrdinal().domain(["red", "black","blue"]).range(["#FF0000", "#000000","#0249fc"]);'
        forceNetwork(Links = g2_d3$links, Nodes = g2_d3$nodes, 
                     Source = 'source', Target = 'target', Value = 'value',fontSize=9,colourScale = JS(ColourScale),
                     NodeID = 'name', Group = 'group',opacityNoHover = 1,opacity = 1,zoom = T)
      }else{
        plot(1,1,type='n',xaxt='n',yaxt='n',xlab = '',ylab = '',bty="n")
      }
    })
  })
  
  output$plot_2d_full <- renderForceNetwork({
    input$goButton
    withProgress(message = 'Generating 2D plot...', value = 0.5,{
      g2 <- get_sub_network_full()
      if(!is.null(g2)){
        g2_d3 <- igraph_to_networkD3(g2, group = V(g2)$label.color)
        g2_d3$nodes$Nodesize = 0
        ColourScale <- 'd3.scaleOrdinal().domain(["red", "black","blue"]).range(["#FF0000", "#000000","#0249fc"]);'
        forceNetwork(Links = g2_d3$links, Nodes = g2_d3$nodes, 
                     Source = 'source', Target = 'target', Value = 'value',fontSize=9,colourScale = JS(ColourScale),
                     NodeID = 'name', Group = 'group',opacityNoHover = 1,opacity = 1,zoom = T)
      }else{
        plot(1,1,type='n',xaxt='n',yaxt='n',xlab = '',ylab = '',bty="n")
      }
    })
  })
  
  output$plot_3d <- renderRglwidget({
    input$goButton
    withProgress(message = 'Generating 3D plot...', value = 0.5,{    
      g2 <- get_sub_network()
      if(!is.null(g2)){
        open3d()
        coords <- layout_with_fr(g2, dim=3)
        rglplot(g2, layout=coords,vertex.size = 1.5,vertex.label.size = 5)
        scene1 <- scene3d()
        rgl.close()
        return(rglwidget(scene1))
      }else{
        plot(1,1,type='n',xaxt='n',yaxt='n',xlab = '',ylab = '',bty="n")
      }
    })
  })
  output$genes <- renderText({
    input$goButton
    withProgress(message = 'Generating gene list...', value = 0.5,{    
      gene_names <- get_sub_network_genes()
      paste(gene_names,sep = '\t')
      
    })
  })  
  output$gene_freq <- renderTable({
    input$goButton
    passcode <- isolate(input$password)
    out_dir <- data_dict[['test']]
    if(passcode %in% names(data_dict)){
      out_dir <- data_dict[[passcode]]
    }
    freq_dir <- paste0(out_dir,'/tmp_freq/')
    withProgress(message = 'Generating gene frequency list...', value = 0.5,{
      Gene_names <- c()
      for(i in list.files(freq_dir,full.names = T)){
        Gene_names <- c(Gene_names,read.csv(i,as.is = T)$x)
      }
    })
    final_table <- sort(table(Gene_names),decreasing = T)
    return(final_table)
  })
})
